"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFees = void 0;
const protocol_contracts_1 = require("@zetachain/protocol-contracts");
const ZRC20_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/zevm/ZRC20.sol/ZRC20.json"));
const ethers_1 = require("ethers");
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const fetchZEVMFees = async function (zrc20, rpcUrl, foreignCoins) {
    const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(rpcUrl);
    const contract = new ethers_1.ethers.Contract(zrc20.address, ZRC20_json_1.default.abi, provider);
    const [, withdrawGasFee] = await contract.withdrawGasFee();
    const gasFee = ethers_1.ethers.BigNumber.from(withdrawGasFee);
    const protocolFee = ethers_1.ethers.BigNumber.from(await contract.PROTOCOL_FLAT_FEE());
    const gasToken = foreignCoins.find((c) => {
        return (c.foreign_chain_id === zrc20.foreign_chain_id && c.coin_type === "Gas");
    });
    return {
        /* eslint-disable */
        ...zrc20,
        totalFee: ethers_1.utils.formatUnits(gasFee, gasToken.decimals),
        gasFee: ethers_1.utils.formatUnits(gasFee.sub(protocolFee), gasToken.decimals),
        protocolFee: ethers_1.utils.formatUnits(protocolFee, gasToken.decimals),
        /* eslint-enable */
    };
};
const fetchCCMFees = async function (chainID, gas) {
    // Skip ZetaChain and Bitcoin
    if (["7000", "7001", "18332", "8332"].includes(chainID))
        return;
    const API = this.getEndpoint("cosmos-http", `zeta_${this.network}`);
    if (!API) {
        throw new Error("API endpoint not found");
    }
    const url = `${API}/zeta-chain/crosschain/convertGasToZeta?chainId=${chainID}&gasLimit=${gas}`;
    const response = await (0, isomorphic_fetch_1.default)(url);
    const data = await response.json();
    const gasFee = ethers_1.ethers.BigNumber.from(data.outboundGasInZeta);
    const protocolFee = ethers_1.ethers.BigNumber.from(data.protocolFeeInZeta);
    return {
        /* eslint-disable */
        chainID,
        totalFee: ethers_1.utils.formatUnits(gasFee.add(protocolFee), 18),
        gasFee: ethers_1.utils.formatUnits(gasFee, 18),
        protocolFee: ethers_1.utils.formatUnits(protocolFee, 18),
        /* eslint-enable */
    };
};
const getFees = async function (gas) {
    let fees = {
        messaging: [],
        omnichain: [],
    };
    const supportedChains = await this.getSupportedChains();
    const foreignCoins = await this.getForeignCoins();
    const addresses = this.network === "mainnet" ? protocol_contracts_1.mainnet : protocol_contracts_1.testnet;
    const zrc20Addresses = addresses.filter((a) => a.type === "zrc20");
    await Promise.all(supportedChains.map(async (n) => {
        try {
            const fee = await fetchCCMFees.call(this, n.chain_id, gas);
            if (fee)
                fees.messaging.push(fee);
        }
        catch (err) {
            console.log(err);
        }
    }));
    await Promise.all(zrc20Addresses.map(async (zrc20) => {
        try {
            const rpcUrl = this.getEndpoint("evm", `zeta_${this.network}`);
            const fee = await fetchZEVMFees(zrc20, rpcUrl, foreignCoins);
            fees.omnichain.push(fee);
        }
        catch (err) {
            console.log(err);
        }
    }));
    return fees;
};
exports.getFees = getFees;
