"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBalances = void 0;
const ERC20_json_1 = __importDefault(require("@openzeppelin/contracts/build/contracts/ERC20.json"));
const protocol_contracts_1 = require("@zetachain/protocol-contracts");
const ZRC20_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/zevm/ZRC20.sol/ZRC20.json"));
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
/**
 * Get token balances of all tokens on all chains connected to ZetaChain.
 *
 * @param this - ZetaChainClient instance.
 * @param options.evmAddress EVM address
 * @param options.btcAddress Bitcoin address
 * @returns
 */
const getBalances = async function ({ evmAddress, btcAddress }) {
    let tokens = [];
    const supportedChains = await this.getSupportedChains();
    const foreignCoins = await this.getForeignCoins();
    foreignCoins.forEach((token) => {
        if (token.coin_type === "Gas") {
            tokens.push({
                chain_id: token.foreign_chain_id,
                coin_type: token.coin_type,
                decimals: token.decimals,
                symbol: token.symbol,
                zrc20: token.zrc20_contract_address,
            });
            tokens.push({
                chain_id: this.getChainId(`zeta_${this.network}`),
                coin_type: "ZRC20",
                contract: token.zrc20_contract_address,
                decimals: token.decimals,
                symbol: token.symbol,
            });
        }
        else if (token.coin_type === "ERC20") {
            tokens.push({
                chain_id: token.foreign_chain_id,
                coin_type: "ERC20",
                contract: token.asset,
                symbol: token.symbol,
                zrc20: token.zrc20_contract_address,
            });
            tokens.push({
                chain_id: this.getChainId(`zeta_${this.network}`),
                coin_type: "ZRC20",
                contract: token.zrc20_contract_address,
                decimals: token.decimals,
                symbol: token.name,
            });
        }
    });
    supportedChains.forEach((chain) => {
        const contract = (0, protocol_contracts_1.getAddress)("zetaToken", chain.chain_name);
        if (contract) {
            tokens.push({
                chain_id: chain.chain_id,
                coin_type: "ERC20",
                contract,
                decimals: 18,
                symbol: "WZETA",
            });
        }
    });
    tokens.push({
        chain_id: this.getChainId(`zeta_${this.network}`),
        coin_type: "Gas",
        decimals: 18,
        symbol: "ZETA",
    });
    tokens = tokens
        .map((token) => {
        const ticker = token.symbol.split("-")[0];
        const chain_name = supportedChains.find((c) => c.chain_id === token.chain_id.toString())?.chain_name;
        return {
            ...token,
            chain_name,
            id: `${token.chain_id.toString().toLowerCase()}__${token.symbol
                .toLowerCase()
                .split(" ")
                .join("_")}`,
            ticker,
        };
    })
        .filter((token) => token.chain_name);
    const balances = await Promise.all(tokens.map(async (token) => {
        const isGas = token.coin_type === "Gas";
        const isBitcoin = ["btc_testnet", "btc_mainnet"].includes(token.chain_name);
        const isERC = token.coin_type === "ERC20";
        const isZRC = token.coin_type === "ZRC20";
        if (isGas && !isBitcoin) {
            let rpc;
            try {
                rpc = await this.getEndpoint("evm", token.chain_name);
            }
            catch (e) {
                return token;
            }
            const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(rpc);
            return provider.getBalance(evmAddress).then((balance) => {
                return { ...token, balance: (0, utils_1.formatUnits)(balance, token.decimals) };
            });
        }
        else if (isGas && isBitcoin && btcAddress) {
            let API;
            try {
                API = this.getEndpoint("esplora", token.chain_name);
            }
            catch (e) {
                return { ...token, balance: undefined };
            }
            return (0, isomorphic_fetch_1.default)(`${API}/address/${btcAddress}`).then(async (response) => {
                const r = await response.json();
                const { funded_txo_sum, spent_txo_sum } = r.chain_stats;
                const balance = ((funded_txo_sum - spent_txo_sum) /
                    100000000).toString();
                return { ...token, balance };
            });
        }
        else if (isERC) {
            let rpc;
            try {
                rpc = await this.getEndpoint("evm", token.chain_name);
            }
            catch (e) {
                return token;
            }
            const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(rpc);
            const contract = new ethers_1.ethers.Contract(token.contract, ERC20_json_1.default.abi, provider);
            const decimals = await contract.decimals();
            return contract.balanceOf(evmAddress).then((balance) => {
                return {
                    ...token,
                    balance: (0, utils_1.formatUnits)(balance, decimals),
                    decimals,
                };
            });
        }
        else if (isZRC) {
            const rpc = await this.getEndpoint("evm", token.chain_name);
            const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(rpc);
            const contract = new ethers_1.ethers.Contract(token.contract, ZRC20_json_1.default.abi, provider);
            return contract.balanceOf(evmAddress).then((balance) => {
                return {
                    ...token,
                    balance: (0, utils_1.formatUnits)(balance, token.decimals),
                };
            });
        }
        else {
            return Promise.resolve(token);
        }
    }));
    return balances;
};
exports.getBalances = getBalances;
