"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendZeta = void 0;
const protocol_contracts_1 = require("@zetachain/protocol-contracts");
const ZetaEth_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/evm/Zeta.eth.sol/ZetaEth.json"));
const ZetaConnectorEth_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/evm/ZetaConnector.eth.sol/ZetaConnectorEth.json"));
const ZetaConnectorZEVM_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/zevm/ZetaConnectorZEVM.sol/ZetaConnectorZEVM.json"));
const ethers_1 = require("ethers");
/**
 *
 * Initiates a cross-chain transfer of ZETA tokens from the source chain to the
 * destination chain.
 *
 * @param this - ZetaChainClient instance.
 * @param options - Send ZETA options.
 * @param options.chain - Source chain label.
 * @param options.destination - Destination chain label.
 * @param options.amount - Amount of ZETA tokens to be sent in human readable form.
 * @param options.recipient - Optional recipient address for the token transfer. If not
 * provided, the token transfer is made to the signer's address.
 * @param options.gasLimit - Optional gas limit on the destination chain.
 *
 * @returns A promise that resolves with the transaction details upon success.
 */
const sendZeta = async function ({ chain, destination, recipient, gasLimit = 500000, amount, }) {
    let signer;
    if (this.signer) {
        signer = this.signer;
    }
    else if (this.wallet) {
        const rpc = this.getEndpoint("evm", chain);
        if (!rpc)
            throw new Error(`No EVM RPC endpoint found for ${chain} chain.`);
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(rpc);
        signer = this.wallet.connect(provider);
    }
    else {
        throw new Error("No wallet or signer found.");
    }
    const fromZetaChain = ["zeta_testnet", "zeta_mainnet"].includes(chain);
    const connector = (0, protocol_contracts_1.getAddress)("connector", chain);
    if (!connector) {
        throw new Error(`connector address on chain ${chain} not found`);
    }
    const zetaToken = (0, protocol_contracts_1.getAddress)("zetaToken", chain);
    if (!zetaToken) {
        throw new Error(`zetaToken address on chain ${chain} not found`);
    }
    const connectorContract = new ethers_1.ethers.Contract(connector, fromZetaChain ? ZetaConnectorZEVM_json_1.default.abi : ZetaConnectorEth_json_1.default.abi, signer);
    const zetaTokenContract = new ethers_1.ethers.Contract(zetaToken, ZetaEth_json_1.default.abi, signer);
    const value = ethers_1.ethers.utils.parseEther(amount);
    if (fromZetaChain) {
        await signer.sendTransaction({ to: zetaToken, value });
    }
    const approveTx = await zetaTokenContract.approve(connector, value);
    await approveTx.wait();
    const destinationChainId = this.getChains()[destination]?.chain_id;
    const destinationAddress = recipient ? recipient : signer.address;
    return await connectorContract.send({
        destinationAddress,
        destinationChainId,
        destinationGasLimit: gasLimit,
        message: ethers_1.ethers.utils.toUtf8Bytes(""),
        zetaParams: ethers_1.ethers.utils.toUtf8Bytes(""),
        zetaValueAndGas: value,
    });
};
exports.sendZeta = sendZeta;
